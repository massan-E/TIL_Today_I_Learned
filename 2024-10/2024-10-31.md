# TIL for 2024-10-31
## 10/31 今日やったこと（学習時間：8h 56m）
久しぶりにめっちゃプログラミングに触れました、けど開始が遅かったのでこの時間です。ｗ

アルゴリズムの勉強、ミニアプリのアルゴリズム考えた<br>
って感じでした

---

### - アルゴリズムの勉強
[いつもの本](https://gihyo.jp/book/2022/978-4-297-12521-9)の続きやりました<br>
ビット演算の続きでビット全探索の問題出てきたんですが１時間ぐらい粘っても意味わかんなかったので<br>
考え方が載ってるページ＋Ｃ++のコードを眺めながらRubyに書き直して理解しようとしたんですが<br>
配列から要素取得する時に配列の外を探索したりしちゃっててエラーになるのでそれについて悩んでたんですが時間来てしまったのであきらめました。<br>

### - ミニアプリのアルゴリズム　[ :notion: 今日の実験のすべて](https://www.notion.so/ActiveRecord-DB-13039de727c380f5a90fed668141c82b?pvs=97#13039de727c38079852fc0b864a24e74)
3日前ぐらいに考え始めたのに全然手を付けてなかったヤツです<br>

何やりたかったかというと「特定のボードに紐づいてるコメントの中からランダムで１件取得」
ってのがやりたいことでした。
ただ、普通に書くと
```Ruby
Board.find(2).comments.sample
```
こんな感じになってid2に関連づいてるコメント全件取得してそこから１件ランダムに取得<br>
みたいになるので、コメント数増えると結構重くなるやろうなと思って改善できないか考え始めました。<br>

あと普通にダサい。なんか。ｗｗ<br>

Rails基礎で作ったアプリのid:2のボードに１０万件ぐらいコメントつけて実験しました<br>

#### １．乱数使ってid決定して.find(乱数)すればよくね？
まず特定のボードに関連づいてるコメント数を数えて（Ｎ）その 0~N までの範囲で乱数を作ってそれ使って.find(乱数)すればよいのでは？<br>
=> コメントテーブルにはいろんなボードに関連づけられてるレコードが様々な順番で保存されてるから期待通りのボードのレコードを取得できない<br>

ほなその乱数の分だけ特定のボードに関連づいてるコメントの頭からスキップして取得すればいいのでは？
```Ruby
Board.find(2).comments.offset(rand(Board.find(2).comments.count)).first
# 例えば　.offset(3) はテーブルの頭から３つスキップする。みたいな意味
```

これでも頭からスキップしていってるから、ケツの方の乱数になると実行時間が爆増する<br>

#### ２．特定のボードに関連づいてるコメントの " id " だけ全取得。そのidの中からランダムで１つ選んでそれを使って.find
```Ruby
Comment.find(Comment.where(board_id: 2).pluck(:id).sample)
```
DBへの問い合わせ回数が一定なので実行速度にブレが無いしバカ早い。<br>

でもこのままだとコメントついてない時に.find(nil)してエラー吐くので<br>
```Ruby
sample_comment_id = Comment.where(board_id: 2).pluck(:id).sample
comment = sample_comment_id ? Comment.find(random_comment_id) : nil
# 三項演算子でsample_comment_idに値が入ってたら（コメントがついてたら）それを使ってレコード取得してそれをcommentに代入
# sample_comment_idに値が入ってなかったら（nilだった場合）（コメントがついてなかったら）nilをcommentに代入
```
これで完成！！<br>
ここまで考えたり、調べたり　＋　Notionにまとめたりで５時間以上かかりましたｗ

#### ３．おまけで学んだこと
##### - 同じクエリが複数回使われないようになるべく結果（データ）を変数に保存しようね。

```Ruby
        # |========== クエリ１回目 ============|　　　　　　　　　|=========== クエリ２回目 ===========|　　　　　　　　　　　　　　　　　　　
comment = Comment.where(board_id: 2).pluck(:id) ? Comment.find(Comment.where(board_id: 2).pluck(:id).sample) : nil
```
例えばこれやとなんであかんの？っていうと、変数に結果を保存しない場合<br>

##### 全く同じクエリが２回発行されててDBへの問い合わせが２回発生してるから実行時間が２倍になっとる！！！

なので一回目で取得した結果（データ）そのものを変数に保存しておいてその中のデータに対して操作しようね、ってこと。<br>



##### - ActiveRecord有能すぎ
```ruby
Board.find(2).comments.sample
# 関連づいてるコメント全件取得　→　それに対してsample　みたいなクエリになってる
# "SELECT `comments`.* FROM `comments` WHERE `comments`.`board_id` = 2" コレやった後に.sample

Board.find(2).comments.offset(rand(Board.find(2).comments.count)).first
# 上と同じようにBoard.find(2).commentsで全件取得してからそれに対して操作行ってると思ったら
# 取得せずに関連づいてるものの中からランダムで取得してた
# SELECT `boards`.* FROM `boards` WHERE `boards`.`id` = 2 LIMIT 1
# SELECT `boards`.* FROM `boards` WHERE `boards`.`id` = 2 LIMIT 1
# SELECT COUNT(*) FROM `comments` WHERE `comments`.`board_id` = 2       
# SELECT `comments`.* FROM `comments` WHERE `comments`.`board_id` = 2 ORDER BY `comments`.`id` ASC LIMIT 1 OFFSET 39631
```

メソッドチェーンは機械的にドット（.）まででいったん処理してからその結果に対して次のドットまでの処理をすると思ってたけど<br>

ActiveRecordは処理が早くなるように全体を考えて良しなにクエリ発行してくれてた・・・偉すぎ。<br>

### まぁいうて100ms = 0.1秒やからこの実験もほとんど意味ないねんけどな！！

---

### 目標達成度
- [x] しかっかりねて朝ごはん食べる
- [x] GitHubの草はやし
- [x] ミニアプリの問題解決できるかいろいろ試す
- [x] アルゴリズム２時間勉強

今日はいっぱいやったぞ！明日は面談や！<br>

### - 明日やること、目標
- [x] しかっかりねて朝ごはん食べる
- [x] GitHubの草はやし
- [x] ミニアプリの全体をテストアプリで作ってみる
- [x] アルゴリズム２時間勉強

ミニアプリすすめるぞ！！<br>

---

あくてぃぶれこーどといっぱいあそべてたのしかったです<br>
眠いからお気持ち表明もとくになし！！けど今日はめっちゃ楽しかったし勉強になった！<br>
明日の夜アウトプット会でちゃんと今日のことアウトプットします。時間内に終わるかな・・・ｗ<br>
では、おやすみなさい。<br>