# TIL for 2025-06-15
## とりあえずメモ 6/15
今日の目標：昨日作った星レビューでつけた星をもとに番組ごとに獲得した星が多いユーザーをリストアップし多い順にランキングをつける。
 
### ER図（関連してる部分だけ）
[![Image from Gyazo](https://i.gyazo.com/0ea5e017267efdee15f51c9f865b9f52.png)](https://gyazo.com/0ea5e017267efdee15f51c9f865b9f52)
 
AIに出してもらったらいつまでもSQL弱いままなんでまたseedで10万件のLetter作って`rails c`でカタカタやった（前回10万レコードやったのはこれ → https://school.runteq.jp/v3/social_portfolios/1272/tech_articles/363）
ルールとしてAI一切禁止
 
`db/seeds/development.rb`
```ruby
if Rails.env.development?
  5001.times do |i|
    User.create!(
      name: "#{Faker::Games::Overwatch.hero}_id_#{i}",
      password: "password",
      password_confirmation: "password",
      confirmed_at: Time.current,
      email: "#{Faker::Internet.unique.email}_id_#{i}"
    )
  end

  user_ids = User.ids
  user = User.find(1)
  user.update(name: "admin", admin: true, email: "ex@ex.com")

  # programs
  50.times do |index|
    user = User.find(user_ids.sample)
    user.programs.create!(title: "番組タイトル#{index}",
                          body: "番組本文#{Faker::Games::Overwatch.quote}",
                          publish: true
                          )
  end

  program_ids = Program.ids

  # letterboxes
  100.times do |index|
    program = Program.find(program_ids.sample)
    program.letterboxes.create!(title: "お便り箱タイトル#{index}",
                                body: "お便り箱本文#{Faker::Games::Overwatch.quote}")
  end

  letterbox_ids = Letterbox.ids

  # letters
  100000.times do |index|
    letterbox = Letterbox.find(letterbox_ids.sample)
    letterbox.letters.create!(
      title: "letterタイトル#{index}",
      body: "letter本文#{Faker::Games::Overwatch.quote}",
      user_id: user_ids.sample,
      radio_name: "ラジオネーム#{index}", # Fakerの代わりに連番を使用
      program_id: letterbox.program.id,
      star: rand(0..5) # ランダムな星の数を設定
    )
  end
end

```

適当計算により10万件のレコードを配分するために以下のように設定
- program（番組）：50件　（テキトー）
- letter_box （お便り箱）：100件　（program 1 につき2つ）
- user：5001 （一人当たり20件のletter送ってる想定＋adminユーザー）

seed挿入のために`db:reset`
```bash
myapp(dev)> docker compose exec web bash
myapp(dev)> rails db:reset --trace        # --traceで今何やってるかログをある程度流せるらしい
```
 
クソほど時間かかるしログ流れんから`--trace`オプション付けてみたけどあんま意味なかった
時間かかりすぎて寝落ちした ( - 2時間）
 
### こっからレベルの低いActive Record操作が続きます。
#### letterはランダムなprogramに紐づけたからとりあえず一番letterがついてる番組を取り出してみる。（それに対してユーザーごとの星の集計すればいい）
 
```bash
myapp(dev)> Program.all.map { |program| program.letters.count }

=> 
[2001,
 0,
 989,
 2012,
 3916,
 2013, ...
```
いきなりRubyのメソッドにぶち込む暴挙
しかも配列に入ってるだけやから扱いにくそう。ソートしても一番多いのがどの番組かわからん
 
Letterモデルにprogram_id保存してあるからそれでgroup byすりゃいんじゃね
```bash
myapp(dev)> Letter.group(:program_id)

  Letter Load (0.7ms)  SELECT "letters".* FROM "letters" GROUP BY "letters"."program_id" /* loading for pp */ LIMIT 11 /*application='Myapp'*/
An error occurred when inspecting the object: #<ActiveRecord::StatementInvalid:"PG::GroupingError: ERROR:  column \"letters.id\" must appear in the GROUP BY clause or be used in an aggregate function\nLINE 1: SELECT \"letters\".* FROM \"letters\" GROUP BY \"letters\".\"progra...\n
# エラー
# column \"letters.id\" must appear in the GROUP BY clause or be used in an aggregate function
# 列「letters.id」はGROUP BY句に出現するか、集計関数で使用される必要があります。
```
 
おいなんかエラー出てるぞ
[Railsガイド](https://railsguides.jp/v6.0/active_record_querying.html#%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97%E5%8C%96%E3%81%95%E3%82%8C%E3%81%9F%E9%A0%85%E7%9B%AE%E3%81%AE%E5%90%88%E8%A8%88)
[その他](https://pikawaka.com/rails/group)
 
groupの後にsumとかcountとか入れるのかね（なんか前もどっかで引っかかった気がするこれ）
 
```bash
myapp(dev)> Letter.group(:program_id).count
  Letter Count (3.5ms)  SELECT COUNT(*) AS "count_all", "letters"."program_id" AS "letters_program_id" FROM "letters" GROUP BY "letters"."program_id" /*application='Myapp'*/
=> 
{1=>2001,
 3=>989,
 4=>2012,
 5=>3916,
 6=>2013, ...
```
 
ほうほう、出てきたね。で、これをletter多い順に並び変えと
 
```bash
myapp(dev)> Letter.group(:program_id).count.sort_by{ | k , v | -v }

  Letter Count (3.3ms)  SELECT COUNT(*) AS "count_all", "letters"."program_id" AS "letters_program_id" FROM "letters" GROUP BY "letters"."program_id" /*application='Myapp'*/
=> 
[[17, 7116],
 [14, 6948],
 [47, 5074],
 [24, 4873],
 [36, 4812], ...
```
 
二次元配列のsortは`<=>`こんなんつけるやつ覚えてたけどこっちのが直感的じゃね？
https://zenn.dev/k_ori/articles/df194cbd0b985e
 
それは**"ソート"**このぐらいのソートならわざわざRubyでやんなくてもSQLでやったほうが早そうじゃね
 
```bash
myapp(dev)> Letter.group(:program_id).count.order("count_all desc")

  Letter Count (3.3ms)  SELECT COUNT(*) AS "count_all", "letters"."program_id" AS "letters_program_id" FROM "letters" GROUP BY "letters"."program_id" /*application='Myapp'*/
(myapp):69:in `<main>': undefined method `order' for an instance of Hash (NoMethodError)
# エラー

myapp(dev)> Letter.group(:program_id).order("count_all desc").count

  Letter Count (3.4ms)  SELECT COUNT(*) AS "count_all", "letters"."program_id" AS "letters_program_id" FROM "letters" GROUP BY "letters"."program_id" ORDER BY count_all desc /*application='Myapp'*/
=> 
{17=>7116,
 14=>6948,
 47=>5074,
 24=>4873,
 36=>4812, ...
```
 
なんでやねん、SQL通りの順番のイメージやったら`.count.order("count_all desc")`やろがい！！
 
まぁええわとりあえずprogram_id:17が一番お便りついてんのね
それにしても偏りすぎやろ・・・10万÷50って2000なんですけど；
 
#### programごとにstar獲得数多いユーザーを順番に出力
まぁいったん`program.letters.group(:user_id)`でユーザーごとにまとめてそのuser_idごとにstar数えればいいんでしょーよ
いったん`group(:user_id)`までで出力してみよ
 
program編集初期化
```bash
myapp(dev)> program = Program.find(17)
```
 
```bash
myapp(dev)> program.letters.group(:user_id)

  Letter Load (0.4ms)  SELECT "letters".* FROM "letters" WHERE "letters"."program_id" = 17 GROUP BY "letters"."user_id" /* loading for pp */ LIMIT 11 /*application='Myapp'*/
An error occurred when inspecting the object: #<ActiveRecord::StatementInvalid:"PG::GroupingError: ERROR:  column \"letters.id\" must appear in the GROUP BY clause or be used in an aggregate function\nLINE 1: SELECT \"letters\".* FROM \"letters\" WHERE \"letters\".\"program_i...\n
# エラー
# column \"letters.id\" must appear in the GROUP BY clause or be used in an aggregate function
# 列「letters.id」はGROUP BY句に出現するか、集計関数で使用される必要があります。
```
 
あーハイハイ、coutとかつけりゃいいんでしょ？
もしかして`sum(:star)`とかで行けんじゃね
 
```bash
myapp(dev)> program.letters.group(:user_id).sum(:star)
  
Letter Sum (5.1ms)  SELECT SUM("letters"."star") AS "sum_star", "letters"."user_id" AS "letters_user_id" FROM "letters" WHERE "letters"."program_id" = 17 GROUP BY "letters"."user_id" /*application='Myapp'*/
=> 
{1489=>9,
 4790=>8,
 273=>3,
 3936=>11,
 2574=>12, ...
```
 
ということであとは並べ替えさせていただいて。
 
```bash
myapp(dev)> program.letters.group(:user_id).order(sum_star: :desc).sum(:star)
  
Program Load (0.4ms)  SELECT "programs".* FROM "programs" WHERE "programs"."id" = 17 LIMIT 1 /*application='Myapp'*/
  Letter Sum (3.6ms)  SELECT SUM("letters"."star") AS "sum_star", "letters"."user_id" AS "letters_user_id" FROM "letters" WHERE "letters"."program_id" = 17 GROUP BY "letters"."user_id" ORDER BY "sum_star" DESC /*application='Myapp'*/
=> 
{2734=>24,
 2345=>23,
 4048=>22,
 1602=>21,
 1763=>20, ...
```

7000件近くても4msやからいいね、今回はアルゴリズム考えなくてよさそう。
 
ちなみに`Letter`全体（10万件）に対してやっても13msやからマジで大丈夫そう
 
```bash
myapp(dev)> Letter.group(:user_id).order(sum_star: :desc).sum(:star)
  
Letter Sum (13.2ms)  SELECT SUM("letters"."star") AS "sum_star", "letters"."user_id" AS "letters_user_id" FROM "letters" GROUP BY "letters"."user_id" ORDER BY "sum_star" DESC /*application='Myapp'*/
=> 
{4393=>106,
 3666=>104,
 4290=>101,
 2120=>98,
 3009=>98, ...
```
 
あとはユーザーついてないletter除外してランキングの期間指定のデモとして日付も指定して完成
```bash
myapp(dev)> Letter.where.not(user: nil).where("created_at < ?" , "2025-06-30").group(:user_id).order(sum_star: :desc).sum(:star)

  Letter Sum (12.1ms)  SELECT SUM("letters"."star") AS "sum_star", "letters"."user_id" AS "letters_user_id" FROM "letters" WHERE "letters"."user_id" IS NOT NULL AND (created_at < '2025-06-30') GROUP BY "letters"."user_id" ORDER BY "sum_star" DESC /*application='Myapp'*/
=> 
{4393=>106,
 3666=>104,
 4290=>101,
 2120=>98,
 3009=>98, ...
```
 
#### おまけ
頭の悪いワイが最初に考えたゴミ↓
```bash
myapp(dev)> Letter.all.group_by(&:program_id)
```
 
Letter.allでSQL途切れて持ってきた後にRubyのgroup_byやってるからゲロ遅い
